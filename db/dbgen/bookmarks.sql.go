// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookmarks.sql

package dbgen

import (
	"context"
)

const addBookmarkToCollection = `-- name: AddBookmarkToCollection :exec
INSERT OR IGNORE INTO bookmark_collections (bookmark_id, collection_id) VALUES (?, ?)
`

type AddBookmarkToCollectionParams struct {
	BookmarkID   int64 `json:"bookmark_id"`
	CollectionID int64 `json:"collection_id"`
}

func (q *Queries) AddBookmarkToCollection(ctx context.Context, arg AddBookmarkToCollectionParams) error {
	_, err := q.db.ExecContext(ctx, addBookmarkToCollection, arg.BookmarkID, arg.CollectionID)
	return err
}

const addTagToBookmark = `-- name: AddTagToBookmark :exec
INSERT OR IGNORE INTO bookmark_tags (bookmark_id, tag_id) VALUES (?, ?)
`

type AddTagToBookmarkParams struct {
	BookmarkID int64 `json:"bookmark_id"`
	TagID      int64 `json:"tag_id"`
}

func (q *Queries) AddTagToBookmark(ctx context.Context, arg AddTagToBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, addTagToBookmark, arg.BookmarkID, arg.TagID)
	return err
}

const countBookmarks = `-- name: CountBookmarks :one
SELECT COUNT(*) FROM bookmarks
`

func (q *Queries) CountBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookmarksBySource = `-- name: CountBookmarksBySource :one
SELECT COUNT(*) FROM bookmarks WHERE source_type = ?
`

func (q *Queries) CountBookmarksBySource(ctx context.Context, sourceType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarksBySource, sourceType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookmarksInCollection = `-- name: CountBookmarksInCollection :one
SELECT COUNT(*) FROM bookmark_collections WHERE collection_id = ?
`

func (q *Queries) CountBookmarksInCollection(ctx context.Context, collectionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarksInCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at
`

type CreateBookmarkParams struct {
	Url         string  `json:"url"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Summary     *string `json:"summary"`
	SourceType  string  `json:"source_type"`
	FaviconUrl  *string `json:"favicon_url"`
	ImageUrl    *string `json:"image_url"`
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, createBookmark,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.Summary,
		arg.SourceType,
		arg.FaviconUrl,
		arg.ImageUrl,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Summary,
		&i.SourceType,
		&i.FaviconUrl,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (name, description, icon) VALUES (?, ?, ?)
RETURNING id, name, description, icon, created_at
`

type CreateCollectionParams struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Icon        *string `json:"icon"`
}

// Collections
func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, createCollection, arg.Name, arg.Description, arg.Icon)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CreatedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name, color) VALUES (?, ?)
ON CONFLICT(name) DO UPDATE SET name = excluded.name
RETURNING id, name, color
`

type CreateTagParams struct {
	Name  string  `json:"name"`
	Color *string `json:"color"`
}

// Tags
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, arg.Name, arg.Color)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE id = ?
`

func (q *Queries) DeleteBookmark(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, id)
	return err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE id = ?
`

func (q *Queries) DeleteCollection(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const getBookmark = `-- name: GetBookmark :one
SELECT id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at FROM bookmarks WHERE id = ?
`

func (q *Queries) GetBookmark(ctx context.Context, id int64) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmark, id)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Summary,
		&i.SourceType,
		&i.FaviconUrl,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookmarkByURL = `-- name: GetBookmarkByURL :one
SELECT id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at FROM bookmarks WHERE url = ?
`

func (q *Queries) GetBookmarkByURL(ctx context.Context, url string) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmarkByURL, url)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Summary,
		&i.SourceType,
		&i.FaviconUrl,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookmarkCollections = `-- name: GetBookmarkCollections :many
SELECT c.id, c.name, c.description, c.icon, c.created_at FROM collections c
JOIN bookmark_collections bc ON c.id = bc.collection_id
WHERE bc.bookmark_id = ?
`

func (q *Queries) GetBookmarkCollections(ctx context.Context, bookmarkID int64) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarkCollections, bookmarkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarkTags = `-- name: GetBookmarkTags :many
SELECT t.id, t.name, t.color FROM tags t
JOIN bookmark_tags bt ON t.id = bt.tag_id
WHERE bt.bookmark_id = ?
`

func (q *Queries) GetBookmarkTags(ctx context.Context, bookmarkID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarkTags, bookmarkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarksByTag = `-- name: GetBookmarksByTag :many
SELECT b.id, b.url, b.title, b.description, b.summary, b.source_type, b.favicon_url, b.image_url, b.created_at, b.updated_at FROM bookmarks b
JOIN bookmark_tags bt ON b.id = bt.bookmark_id
WHERE bt.tag_id = ?
ORDER BY b.created_at DESC
LIMIT ? OFFSET ?
`

type GetBookmarksByTagParams struct {
	TagID  int64 `json:"tag_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetBookmarksByTag(ctx context.Context, arg GetBookmarksByTagParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarksByTag, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Summary,
			&i.SourceType,
			&i.FaviconUrl,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarksInCollection = `-- name: GetBookmarksInCollection :many
SELECT b.id, b.url, b.title, b.description, b.summary, b.source_type, b.favicon_url, b.image_url, b.created_at, b.updated_at FROM bookmarks b
JOIN bookmark_collections bc ON b.id = bc.bookmark_id
WHERE bc.collection_id = ?
ORDER BY b.created_at DESC
LIMIT ? OFFSET ?
`

type GetBookmarksInCollectionParams struct {
	CollectionID int64 `json:"collection_id"`
	Limit        int64 `json:"limit"`
	Offset       int64 `json:"offset"`
}

func (q *Queries) GetBookmarksInCollection(ctx context.Context, arg GetBookmarksInCollectionParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarksInCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Summary,
			&i.SourceType,
			&i.FaviconUrl,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollection = `-- name: GetCollection :one
SELECT id, name, description, icon, created_at FROM collections WHERE id = ?
`

func (q *Queries) GetCollection(ctx context.Context, id int64) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CreatedAt,
	)
	return i, err
}

const getTag = `-- name: GetTag :one
SELECT id, name, color FROM tags WHERE id = ?
`

func (q *Queries) GetTag(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTag, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, color FROM tags WHERE name = ?
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.Color)
	return i, err
}

const listBookmarks = `-- name: ListBookmarks :many
SELECT id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at FROM bookmarks ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBookmarks(ctx context.Context, arg ListBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Summary,
			&i.SourceType,
			&i.FaviconUrl,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookmarksBySource = `-- name: ListBookmarksBySource :many
SELECT id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at FROM bookmarks WHERE source_type = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListBookmarksBySourceParams struct {
	SourceType string `json:"source_type"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

func (q *Queries) ListBookmarksBySource(ctx context.Context, arg ListBookmarksBySourceParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarksBySource, arg.SourceType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Summary,
			&i.SourceType,
			&i.FaviconUrl,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollections = `-- name: ListCollections :many
SELECT id, name, description, icon, created_at FROM collections ORDER BY name
`

func (q *Queries) ListCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, color FROM tags ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeBookmarkFromCollection = `-- name: RemoveBookmarkFromCollection :exec
DELETE FROM bookmark_collections WHERE bookmark_id = ? AND collection_id = ?
`

type RemoveBookmarkFromCollectionParams struct {
	BookmarkID   int64 `json:"bookmark_id"`
	CollectionID int64 `json:"collection_id"`
}

func (q *Queries) RemoveBookmarkFromCollection(ctx context.Context, arg RemoveBookmarkFromCollectionParams) error {
	_, err := q.db.ExecContext(ctx, removeBookmarkFromCollection, arg.BookmarkID, arg.CollectionID)
	return err
}

const removeTagFromBookmark = `-- name: RemoveTagFromBookmark :exec
DELETE FROM bookmark_tags WHERE bookmark_id = ? AND tag_id = ?
`

type RemoveTagFromBookmarkParams struct {
	BookmarkID int64 `json:"bookmark_id"`
	TagID      int64 `json:"tag_id"`
}

func (q *Queries) RemoveTagFromBookmark(ctx context.Context, arg RemoveTagFromBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromBookmark, arg.BookmarkID, arg.TagID)
	return err
}

const searchBookmarksFTS = `-- name: SearchBookmarksFTS :many
SELECT id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at FROM bookmarks 
WHERE title LIKE ? OR description LIKE ? OR summary LIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchBookmarksFTSParams struct {
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Summary     *string `json:"summary"`
	Limit       int64   `json:"limit"`
	Offset      int64   `json:"offset"`
}

// Note: FTS search is done via raw SQL in the server code
func (q *Queries) SearchBookmarksFTS(ctx context.Context, arg SearchBookmarksFTSParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, searchBookmarksFTS,
		arg.Title,
		arg.Description,
		arg.Summary,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Summary,
			&i.SourceType,
			&i.FaviconUrl,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookmark = `-- name: UpdateBookmark :one
UPDATE bookmarks SET
    title = ?,
    description = ?,
    summary = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, url, title, description, summary, source_type, favicon_url, image_url, created_at, updated_at
`

type UpdateBookmarkParams struct {
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Summary     *string `json:"summary"`
	ID          int64   `json:"id"`
}

func (q *Queries) UpdateBookmark(ctx context.Context, arg UpdateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, updateBookmark,
		arg.Title,
		arg.Description,
		arg.Summary,
		arg.ID,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Summary,
		&i.SourceType,
		&i.FaviconUrl,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections SET name = ?, description = ?, icon = ? WHERE id = ?
RETURNING id, name, description, icon, created_at
`

type UpdateCollectionParams struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Icon        *string `json:"icon"`
	ID          int64   `json:"id"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, updateCollection,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.ID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CreatedAt,
	)
	return i, err
}
